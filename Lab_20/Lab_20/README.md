# Лабораторна робота №20

## Тема
**SRP: декомпозиція класу OrderProcessor**

---

## Мета роботи
Застосувати принцип єдиної відповідальності (Single Responsibility Principle, SRP) для декомпозиції складного класу `OrderProcessor` на менші, більш сфокусовані компоненти з чітко визначеними відповідальностями.

---

## Опис предметної області
У роботі розглядається обробка замовлення (`Order`), яка включає:
- валідацію замовлення;
- збереження замовлення;
- відправку email-сповіщення клієнту;
- оновлення статусу замовлення.

---

## Структура проєкту

```
lab20
│
├── Program.cs
│
├── Models
│   └── Order.cs
│
├── Interfaces
│   ├── IOrderValidator.cs
│   ├── IOrderRepository.cs
│   └── IEmailService.cs
│
├── Services
│   ├── OrderProcessor.cs      // початковий клас (порушує SRP)
│   ├── OrderService.cs        // рефакторинг з SRP та DI
│   ├── OrderValidator.cs
│   ├── InMemoryOrderRepository.cs
│   └── ConsoleEmailService.cs
```

---

## Реалізація початкового класу

Клас `OrderProcessor` реалізує одразу декілька відповідальностей: валідацію, збереження, відправку email та зміну статусу замовлення. Такий підхід порушує принцип SRP і є прикладом **God Object**.

---

## Рефакторинг згідно SRP

Для дотримання принципу SRP функціональність була розділена на окремі інтерфейси та їх реалізації:

- `IOrderValidator` — відповідає за валідацію замовлення;
- `IOrderRepository` — відповідає за збереження та отримання замовлень;
- `IEmailService` — відповідає за відправку email-повідомлень;
- `OrderService` — координує роботу компонентів.

Клас `OrderService` отримує залежності через конструктор, що відповідає принципу **Dependency Injection**.

---

## Демонстрація роботи програми

У методі `Main` створюються екземпляри реалізацій інтерфейсів та передаються в `OrderService`. Демонструється обробка:
- валідного замовлення;
- невалідного замовлення.

Результати роботи виводяться у консоль:
![Screen](image.png)

---

## Відповідність вимогам

-  Створено консольний проєкт `lab20`;
-  Реалізовано початковий клас `OrderProcessor`, що порушує SRP;
-  Виконано рефакторинг із виділенням інтерфейсів;
-  Реалізовано `OrderService` з використанням Dependency Injection;
-  Продемонстровано роботу програми для різних сценаріїв.

---

## Висновок

У ході лабораторної роботи було продемонстровано порушення принципу єдиної відповідальності та виконано рефакторинг класу `OrderProcessor`. Застосування SRP та Dependency Injection дозволило отримати більш гнучку, зрозумілу та масштабовану архітектуру.

---

**Лабораторна робота виконана відповідно до всіх вимог завдання.**

